# Security
We take security very seriously. This document provides an overview of Infra's security model.

If you have found a security vulnerability please disclose it privately to us by email via security@infrahq.com.

## General Security
### HTTPS
By default Infra and Infra engine communicate via encrypted HTTPS connections with validated certificates. When using self-signed certificates, an error will be printed in the logs. Certificate validation can be strongly enforced using the `--force-tls-verify` flag.

### Authentication
When users login to Infra as a valid user they are issued a session token with a 24 character secret that is randomly generated. The SHA256 hash of this token is stored server-side for token validation. This session token is stored locally under `~/.infra`.

When a user connects to a cluster after login, Infra issues a new JWT signed with an ECDSA signature using P-521 and SHA-512. This JWT is verified by the engine. If JWT and the user role is valid at the destination, the user is granted access.

## Deployment
When deploying Infra, we recommend Infra be deployed in its own namespace to minimize the deployment scope. 

## Sensitive Information

These secrets can be stored in a variety of [secret storage backends](secrets.md), including Kubernetes secrets, Vault, AWS Secrets Manager, AWS SSM (Systems Manager Parameter Store), and some simple options exist for loading secrets from the OS or container, such as: loading secrets from environment variables, loading secrets from files on the file system, and even plaintext secrets directly in the configuration file (though this is not recommended). With all types except for `plaintext`, the respective secret object names are specified in the configuration file and the actual secret is never persisted in Infra's storage. In the case of all secret types (including `plaintext`), the secret data is [encrypted at rest in the db](#Encrypted_At_Rest).

### Okta secrets
Infra uses an Okta application client secret and API token in order to allow users to authenticate via an OpenID Connect (OIDC) authorization code flow.

#### Okta client secret usage:
The client secret is loaded server-side from the specified Kubernetes secret only when a user is logging in via Okta.

#### Okta API token usage:
The Okta API token is only used for read actions. It is retrieved from the kubernetes secret when validating that the Okta connection is valid and when syncing users/groups.

## Encrypted At Rest

Sensitive data is always encrypted at rest in the db using a symmetric key. The symmetric key is stored in the database encrypted by a root key. By default this root key is generated by Infra and stored in Kubernetes secret storage under `infra-x/__root_key`. We strongly recommend enabling encryption-at-rest within Kubernetes for Kubernetes Secrets, or configuring another key provider service such as KMS or Vault.

The process of retrieving the db key is to load the encrypted key from the database, request that the db key be decrypted by the root key, and at which point the db key is used to decrypt all the data. In the case of AWS KMS and Vault, the Infra app never sees the root key, and so these options are preferred over the default built-in `native` key provider.

### Root key configuration examples

Infra uses AWS KMS key service

```yaml
config:
  keys:
    - kind: awskms
      endpoint: https://your.kms.aws.url.example.com
      region: us-east-1
      accessKeyId: kubernetes:awskms/accessKeyID
      secretAccessKey: kubernetes:awskms/secretAccessKey
      encryptionAlgorithm: AES_256
```

Infra uses Vault as a key service

```yaml
config:
  keys:
    - kind: vault
      address: https://your.vault.url.example.com
      transitMount: /transit
      token: kubernetes:vault/token
      namespace:
```

Another alternative is that Infra can manages its own keys but stores them in a secret storage service other than kubernetes. valid secretStorage values are any secrets `name` that is already configured in config under `secrets`, as long as it's one of the types: `vault`, `awsssm`, `awssecretsmanager`, or `kubernetes`. 

If you're using Kubernetes for root key storage, as the config here shows, you should back up the secret offline or to secret storage such as 1Password. If you don't want to be responsible for backing up this key, switch to Vault or KMS (examples above).

```yaml
config:
  keys:
    - kind: native
      secretStorage: kubernetes
```